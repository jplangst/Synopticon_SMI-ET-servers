#include "WampServer.h"


retData WampServer::calibrationData;
bool WampServer::shouldCalibrate = false;

bool WampServer::bPublishCalibrationResult = false;
double WampServer::calX = -1;
double WampServer::calY = -1;

WampServer::WampServer()
{
	closedManually = false;
	shouldLeave = false;
	retID = "";

	UpdateCurrentDisplaySize();
}

WampServer::~WampServer()
{

}

bool WampServer::IsStoppedUnexpectedly()
{
	return StoppedUnexpectedly;
}

void WampServer::LeaveSession() {
	shouldLeave = true;
	closedManually = true;
}

void WampServer::WebsocketStreamer(char* crossbarAddress, std::string _retID) {
	bool debug = false;

	retID = _retID;

	std::string crossbarWSAddress = "ws://";
	crossbarWSAddress.append(crossbarAddress);
	crossbarWSAddress.append("/ws");

	client ws_clinet;
	ws_clinet.init_asio(&io);
	auto transport_ed = std::make_shared < autobahn::wamp_websocketpp_websocket_transport<websocketpp::config::asio_client> >(
		ws_clinet, crossbarWSAddress, debug);

	// create a WAMP session that talks over websocket
	auto session_ed = std::make_shared<autobahn::wamp_session>(io, debug);
	transport_ed->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session_ed));

	// Make sure the continuation futures we use do not run out of scope prematurely.
	// Since we are only using one thread here this can cause the io service to block
	// as a future generated by a continuation will block waiting for its promise to be
	// fulfilled when it goes out of scope. This would prevent the session from receiving
	// responses from the router.
	boost::future<void> connect_future;
	boost::future<void> start_future;
	boost::future<void> join_future;
	boost::future<void> subscription_future;
	boost::future<void> call_future;
	boost::future<void> leave_future_ed;
	boost::future<void> stop_future_ed;

	connect_future = transport_ed->connect().then([&](boost::future<void> connected) {
		try {
			connected.get();
		}
		catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			io.stop();
			return;
		}

		std::cerr << "transport connected" << std::endl;

		start_future = session_ed->start().then([&](boost::future<void> started) {
			try {
				started.get();
			}
			catch (const std::exception& e) {
				std::cerr << e.what() << std::endl;
				io.stop();
				return;
			}

			std::cerr << "Eye Data session started" << std::endl;

			join_future = session_ed->join(std::string("realm1")).then([&](boost::future<uint64_t> joined) {
				//Join the session, if it fails return
				try {
					std::cerr << "joined realm: " << joined.get() << std::endl;
				}
				catch (const std::exception& e) {
					std::cerr << e.what() << std::endl;
					io.stop();
					return;
				}

				subscription_future = session_ed->subscribe("onCalibration", &WampServer::OnCalibration).then([&](boost::future<autobahn::wamp_subscription> subscribed)
				{
					try {
						subscribed.get();
					}
					catch (const std::exception& e) {
						e.what();
						io.stop();
						return;
					}

				});

				//Register the server to the wamp list of servers
				call_future = session_ed->call("registerPublisher", std::tuple<std::string, std::array<std::string, 2>>(std::string("add"), std::array<std::string, 2>{std::string(retID), std::string("remote_tracker")}))
					.then([&](boost::future<autobahn::wamp_call_result> result) {
					try {
						result.get();
					}
					catch (const std::exception& e) {
						std::cerr << "call failed: " << e.what() << std::endl;
						io.stop();
						return;
					}
				});

				//While we are running and the session is ok we stream samples
				while (!shouldLeave) {
					try {
						if (bPublishCalibrationResult) {
							StreamCalibrationResult(session_ed);
						}
						StreamGazeDataSample(session_ed);
						StreamGazeDataFixation(session_ed);
						SleepEx(10, FALSE);
					}
					catch (...) {
						std::exception_ptr eptr = std::current_exception();
					}
				}

				if (closedManually) {
					io.stop();
				}
			});
		});
	});

	std::cerr << "starting io service" << std::endl;
	io.run();
	std::cerr << "stopped io service" << std::endl;

	try {
		shouldLeave = true;
		SleepEx(100, false);
		if (!closedManually) {
			io.stop();
		}

		leave_future_ed = session_ed->leave().then([&](boost::future<std::string> reason) {
			try {
				std::cerr << "left session (" << reason.get() << ")" << std::endl;
			}
			catch (const std::exception& e) {
				std::cerr << "failed to leave session: " << e.what() << std::endl;
				io.stop();
				return;
			}
		});

		stop_future_ed = session_ed->stop().then([&](boost::future<void> stopped) {
			std::cerr << "stopped session" << std::endl;
		});

		SleepEx(500, false);

		if (!closedManually) {
			std::cerr << "Reconnecting WAMP" << std::endl;
			shouldLeave = false;
			StoppedUnexpectedly = true;
			//WebsocketStreamer(crossbarAddress, retID);
		}
	}
	catch (const std::exception& e) {
		return;
	}
}

void WampServer::UpdateCurrentDisplaySize() {

	//Get the size of the primary display
	RECT desktop;
	const HWND hDesktop = GetDesktopWindow();
	GetWindowRect(hDesktop, &desktop);
	DisplayWidth = desktop.right;
	DisplayHeight = desktop.bottom;

	//Get the size of all of the attatched monitors. No way to currently know which monitor that is being used by SMI.
	//MonitorIndex = 0;
	//EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, 0);


	//wampServer->publishScreenSize(width, height);
}

void WampServer::StreamGazeDataSample(std::shared_ptr<autobahn::wamp_session> session) {
	SampleStruct sample;
	bool result = DataContainer::getInstance()->getGazeSample(sample);
	if (result) {

		EyeDataStruct leftEye = sample.leftEye;
		
		//TODO if invalid data can be recieved we need to set it to some known value so we can handle it on the recieving end
		/*if (!Utils::isSampleValid(leftEye)) {
			leftEye.diam;
			leftEye.gazeX;
			leftEye.gazeY;
		}*/

		EyeDataStruct rightEye = sample.rightEye;
		//TODO if invalid data can be recieved we need to set it to some known value so we can handle it on the recieving end
		/*if (!Utils::isSampleValid(rightEye)) {
		rightEye.diam;
		rightEye.gazeX;
		rightEye.gazeY;
		}*/

		float gazeX = ((leftEye.gazeX + rightEye.gazeX) / 2) / DisplayWidth;
		float gazeY = ((leftEye.gazeY + rightEye.gazeY) / 2) / DisplayHeight;

		std::array<double, 14> data = {
			leftEye.diam, leftEye.gazeX, leftEye.gazeY,
			rightEye.diam, rightEye.gazeX, rightEye.gazeY,
			leftEye.eyePositionX, leftEye.eyePositionY, leftEye.eyePositionZ,
			rightEye.eyePositionX, rightEye.eyePositionY, rightEye.eyePositionZ,
			gazeX, gazeY
		};

		msgpack::type::tuple<std::string, std::array<double, 14>> arguments =
			std::make_tuple(retID.c_str(), data);

		session->publish(std::string("RETDataSample"), arguments);
		//std::cerr << "Eye Data published" << std::endl;

		//TODO should the sample be deleted?
	}
}

void WampServer::StreamCalibrationResult(std::shared_ptr<autobahn::wamp_session> session)
{
		//RET ID, position x, position y, timestamp, duration
		msgpack::type::tuple<std::string, double, double> arguments =
			std::make_tuple(retID.c_str(), WampServer::calX, WampServer::calY);

		session->publish(std::string("RETCalibrationResult"), arguments);
		std::cerr << "Calibration Result published" << calX << " " << calY << std::endl;

		WampServer::bPublishCalibrationResult = false;
}

void WampServer::StreamGazeDataFixation(std::shared_ptr<autobahn::wamp_session> session)
{
	FixationGroup* sample = nullptr;
	bool result = DataContainer::getInstance()->getGazeFixation(sample);
	if (result && sample) {
		//RET ID, position x, position y, timestamp, duration
		pair<double, double> position = sample->getCentroid();
		msgpack::type::tuple<std::string, double, double, long long, double> arguments =
			std::make_tuple(retID.c_str(), position.first, position.second, sample->getTimestamp(), sample->getDuration());

		session->publish(std::string("RETDataFixations"), arguments);
		//std::cerr << "FIxation Data published" << sample->getDuration() << std::endl;

		delete sample;
		sample = nullptr;
	}
}

bool WampServer::ShouldCalibrate() {
	return WampServer::shouldCalibrate;
}

void WampServer::HasCalibrated() {
	WampServer::shouldCalibrate = false;
}

retData WampServer::getCalibrationData() {
	return WampServer::calibrationData;
}

void WampServer::OnCalibration(const autobahn::wamp_event& event) {
	WampServer::shouldCalibrate = true;

	//Calibration Specific
	WampServer::calibrationData.method = event.argument<int>(0);
	WampServer::calibrationData.speed = event.argument<int>(1);
	WampServer::calibrationData.autoAccept = event.argument<int>(2);
	WampServer::calibrationData.displayDevice = event.argument<int>(3);
	
	//RED Geometry Specific
	WampServer::calibrationData.Depth = event.argument<int>(4);
	WampServer::calibrationData.Height = event.argument<int>(5);
	WampServer::calibrationData.ScreenWidth = event.argument<int>(6);
	WampServer::calibrationData.ScreenHeight = event.argument<int>(7);
	WampServer::calibrationData.REDAngle = event.argument<int>(8);
}

void WampServer::publishCalibrationResult(double _calX, double _calY) {
	WampServer::calX = _calX;
	WampServer::calY = _calY;

	WampServer::bPublishCalibrationResult = true;
}