#include "SceneCameraWAMP.h"

SceneCameraWAMP::SceneCameraWAMP() {
	closedManually = false;
	shouldLeave = false;
	StoppedUnexpectedly = false;
	//imagerServerThread = thread(&ImagerServer::updateServer, &imagerServer);
	vpxThread = thread(&VpxEncoder::encodeFrame, &vpxEncoder);
}

SceneCameraWAMP::~SceneCameraWAMP() {
	//imagerServerThread.join();
	vpxThread.join();
}

void SceneCameraWAMP::LeaveSession() {
	shouldLeave = true;
	closedManually = true;
	vpxEncoder.stopEncoding();
	//imagerServer.StopServer();
}

int reconnection_attempts = 0;

bool SceneCameraWAMP::IsStoppedUnexpectedly()
{
	return StoppedUnexpectedly;
}


void SceneCameraWAMP::WebsocketStreamer(char* crossbarAddress, char* _glassesID) {	
	bool debug = false;
	glassesID = std::string(_glassesID);
	std::string crossbarWSAddress = "ws://";
	crossbarWSAddress.append(crossbarAddress);
	crossbarWSAddress.append("/ws");

	client ws_clinet;
	ws_clinet.init_asio(&io);
	auto transport_ed = std::make_shared < autobahn::wamp_websocketpp_websocket_transport<websocketpp::config::asio_client> >(
		ws_clinet, crossbarWSAddress, debug);

	// create a WAMP session that talks over websocket
	auto session_ed = std::make_shared<autobahn::wamp_session>(io, debug);
	transport_ed->attach(std::static_pointer_cast<autobahn::wamp_transport_handler>(session_ed));

	// Make sure the continuation futures we use do not run out of scope prematurely.
	// Since we are only using one thread here this can cause the io service to block
	// as a future generated by a continuation will block waiting for its promise to be
	// fulfilled when it goes out of scope. This would prevent the session from receiving
	// responses from the router.
	boost::future<void> connect_future;
	boost::future<void> start_future;
	boost::future<void> join_future;
	boost::future<void> leave_future_ed;
	boost::future<void> stop_future_ed;
	boost::future<void> call_future;

	connect_future = transport_ed->connect().then([&](boost::future<void> connected) {
		try {
			connected.get();
		}
		catch (const std::exception& e) {
			std::cerr << e.what() << std::endl;
			io.stop();
			return;
		}

		std::cerr << "transport connected" << std::endl;

		start_future = session_ed->start().then([&](boost::future<void> started) {
			try {
				started.get();
			}
			catch (const std::exception& e) {
				std::cerr << e.what() << std::endl;
				io.stop();
				return;
			}

			std::cerr << "Scene Camera session started" << std::endl;

			join_future = session_ed->join(std::string("realm1")).then([&](boost::future<uint64_t> joined) {
				//Join the session, if it fails return
				try {
					std::cerr << "joined realm: " << joined.get() << std::endl;
				}
				catch (const std::exception& e) {
					std::cerr << e.what() << std::endl;
					io.stop();
					return;
				}

				call_future = session_ed->call("registerPublisher", std::tuple<std::string, std::array<std::string, 2>>(std::string("add"), std::array<std::string, 2>{std::string(_glassesID), std::string("glasses")} ))
					.then([&](boost::future<autobahn::wamp_call_result> result) {
					try {
						result.get();
					}
					catch (const std::exception& e) {
						std::cerr << "call failed: " << e.what() << std::endl;
						io.stop();
						return;
					}
				});

				//While we are running and the session is ok we stream samples
				while (!shouldLeave) {
					try {
						StreamGazeDataSample(session_ed);
						//StreamSceneCamera(session_ed);
						//StreamEncodedSceneCamera(session_ed);
						StreamVPEncodedSceneCamera(session_ed);
						SleepEx(10, FALSE);
					}
					catch (...) {
						std::exception_ptr eptr = std::current_exception();
					}
				}

				if (closedManually) {
					io.stop();
				}
			});
		});
	});

	std::cerr << "starting io service" << std::endl;
	io.run();
	std::cerr << "stopped io service" << std::endl;

	try {
		shouldLeave = true;
		SleepEx(100, false);

		if (!closedManually) {
			io.stop();
			
		}

		leave_future_ed = session_ed->leave().then([&](boost::future<std::string> reason) {
			try {
				std::cerr << "left session (" << reason.get() << ")" << std::endl;
			}
			catch (const std::exception& e) {
				std::cerr << "failed to leave session: " << e.what() << std::endl;
				io.stop();
				return;
			}
		});

		stop_future_ed = session_ed->stop().then([&](boost::future<void> stopped) {
			std::cerr << "stopped session" << std::endl;
		});

		SleepEx(100 + 200 * reconnection_attempts, false);
		reconnection_attempts++;

		if (!closedManually) {
			std::cerr << "Reconnecting WAMP" << std::endl;
			shouldLeave = false;
			StoppedUnexpectedly = true;
			//WebsocketStreamer(crossbarAddress, _glassesID);
		}
	}
	catch (const std::exception& e) {
		return;
	}
}

void SceneCameraWAMP::StreamSceneCamera(std::shared_ptr<autobahn::wamp_session> session) {
	if (imagerServer.isImageReady()) {
		std::vector<uint8_t> compressedImage = imagerServer.getImage();
		//msgpack::type::array_ref<uint8_t> msgpackArray(compressedImage);
		int imageWidth = 0;
		int imageHeight = 0;
		int stride = 0;
		imagerServer.getImageProperties(imageWidth, imageHeight, stride);
		
		msgpack::type::tuple<std::string, std::vector<uint8_t>, int, int, int> arguments = msgpack::type::make_tuple(glassesID.c_str(), compressedImage, imageWidth, imageHeight, stride);
		
		//std::cerr << "ID: " << glassesID.c_str() << "Encoded Image Size: " << compressedImage.size() << std::endl;
		try{
			session->publish(std::string("ETGSceneCamera"), arguments);
		}
		catch (const std::exception& e) {
			e.what();
			io.stop();
		}

		//std::cerr << "scene camera image published" << std::endl;

		imagerServer.prepareNextImage();
	}
}

void SceneCameraWAMP::StreamEncodedSceneCamera(std::shared_ptr<autobahn::wamp_session> session) {
	iViewDataStreamH264SceneImage encodedImage;
	bool hasSample = DataContainer::getInstance()->getEncodedSceneCameraSample(encodedImage);

	if (hasSample) {
		std::vector<uint8_t> image;
		image.assign((uint8_t*)encodedImage.data, (uint8_t*)encodedImage.data + encodedImage.dataSize);

		msgpack::type::tuple<std::string, std::vector<uint8_t>, uint32_t, uint32_t> arguments = msgpack::type::make_tuple(glassesID, image, encodedImage.isKeyFrame, encodedImage.sceneFrameNumber);

		//std::cerr << "ID: " << glassesID.c_str() << " Image Size: " << encodedImage.dataSize << std::endl;
		try {
			session->publish(std::string("ETGEncodedSceneCamera"), arguments);
		}
		catch (const std::exception& e) {
			e.what();
			io.stop();
		}

		//std::cerr << "scene camera image published" << std::endl;
	}
}

int counter = 0;

void SceneCameraWAMP::StreamVPEncodedSceneCamera(std::shared_ptr<autobahn::wamp_session> session) {
	//const vpx_codec_cx_pkt_t* VPEncodedSample;
	EncodedVPXSample encodedImageSample;
	bool hasSample = DataContainer::getInstance()->getVPEncodedSceneCameraSample(encodedImageSample);

	if (hasSample) {

		//if (encodedImageSample.isKeyframe || counter % 2 == 0) {
			msgpack::type::tuple<std::string, std::vector<uint8_t>, int32, int32, int32> arguments = msgpack::type::make_tuple(glassesID, encodedImageSample.imageData, encodedImageSample.isKeyframe,
				encodedImageSample.imageWidth, encodedImageSample.imageHeight);

			std::cerr << "ID: " << glassesID.c_str() << " Keyframe: " << encodedImageSample.isKeyframe << " Image Size: " << encodedImageSample.imageData.size() << " Width: " << encodedImageSample.imageWidth << " Height: " << encodedImageSample.imageHeight << std::endl;
			session->publish(std::string("ETGVPEncodedSceneCamera"), arguments);
		//}
		//counter++;
		//std::cerr << "scene camera image published" << std::endl;
	}

	//if (hasSample) {
	//	int32 keyframe = (VPEncodedSample->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
	//	std::vector<uint8_t> image;
	//	image.assign((uint8_t*)VPEncodedSample->data.frame.buf, (uint8_t*)VPEncodedSample->data.frame.buf + VPEncodedSample->data.frame.sz);
	//	//VPEncodedSample->data.frame.pts;

	//	msgpack::type::tuple<std::string, std::vector<uint8_t>, int32, int32, int32> arguments = msgpack::type::make_tuple(glassesID, image, keyframe, 
	//		vpxEncoder.getImageWidth(), vpxEncoder.getImageHeight());

	//	std::cerr << "ID: " << glassesID.c_str() << " Keyframe: " << keyframe << " Image Size: " << image.size() << " Width: " << vpxEncoder.getImageWidth() << " Height: " << vpxEncoder.getImageHeight() << std::endl;
	//	session->publish(std::string("ETGVPEncodedSceneCamera"), arguments);
	//	//std::cerr << "scene camera image published" << std::endl;
	//}
}

void SceneCameraWAMP::StreamGazeDataSample(std::shared_ptr<autobahn::wamp_session> session) {
	iViewDataStreamGazeSample sample;

	bool sampleFetched = DataContainer::getInstance()->getGazeSample(sample);

	if (sampleFetched)
	{
		iViewEyeSample leftEye = sample.leftEye;

		if (!Utils::isSampleValid(leftEye)) {
			leftEye.pupilConfidence = -1;
			leftEye.pupilRadius = 0;
			leftEye.gazeBasePoint.x = 0;
			leftEye.gazeBasePoint.y = 0;
			leftEye.gazeBasePoint.z = 0;
			leftEye.gazeDirection.x = 0;
			leftEye.gazeDirection.y = 0;
			leftEye.gazeDirection.z = 0;
		}

		iViewEyeSample rightEye = sample.rightEye;
		if (!Utils::isSampleValid(rightEye)) {
			rightEye.pupilConfidence = -1;
			rightEye.pupilRadius = 0;
			rightEye.gazeBasePoint.x = 0;
			rightEye.gazeBasePoint.y = 0;
			rightEye.gazeBasePoint.z = 0;
			rightEye.gazeDirection.x = 0;
			rightEye.gazeDirection.y = 0;
			rightEye.gazeDirection.z = 0;
		}

		std::array<double, 16> data = { leftEye.pupilConfidence, leftEye.pupilRadius,
			leftEye.gazeBasePoint.x, leftEye.gazeBasePoint.y, leftEye.gazeBasePoint.z,
			leftEye.gazeDirection.x, leftEye.gazeDirection.y, leftEye.gazeDirection.z,
			rightEye.pupilConfidence, rightEye.pupilRadius,
			rightEye.gazeBasePoint.x, rightEye.gazeBasePoint.y, rightEye.gazeBasePoint.z,
			rightEye.gazeDirection.x, rightEye.gazeDirection.y, rightEye.gazeDirection.z
		};

		msgpack::type::tuple<std::string, std::array<double, 16>> arguments =
			msgpack::type::make_tuple(glassesID, data);

		session->publish(std::string("EyeDataSample"), arguments);
		//std::cerr << "Eye Data published" << std::endl;
	}
}